#!/usr/bin/env node
import fs from 'fs';
import { execSync } from 'child_process';

const { OPENAI_API_KEY, GITHUB_TOKEN, JUNIT_PATH, COVERAGE_PATH } = process.env;
if (!OPENAI_API_KEY || !GITHUB_TOKEN) {
  console.error('Missing OPENAI_API_KEY or GITHUB_TOKEN');
  process.exit(1);
}

function parseJUnit(path) {
  if (!fs.existsSync(path)) return [];
  const xml = fs.readFileSync(path, 'utf8');
  const failures = [];
  const regex = /<testcase[^>]*classname="([^"]+)"[^>]*name="([^"]+)"[^>]*>([\s\S]*?)<\/testcase>/g;
  let match;
  while ((match = regex.exec(xml))) {
    if (/<failure/.test(match[3])) {
      const msg = match[3].match(/<failure[^>]*>([\s\S]*?)<\/failure>/);
      failures.push({ classname: match[1], name: match[2], message: msg ? msg[1].trim() : '' });
    }
  }
  return failures;
}

function parseCoverage(path) {
  if (!fs.existsSync(path)) return null;
  const data = JSON.parse(fs.readFileSync(path, 'utf8'));
  const total = data.total || data;
  return Object.keys(total)
    .map(k => `${k}: ${total[k].covered}/${total[k].total} (${total[k].pct}%)`)
    .join('\n');
}

async function generatePatch(prompt) {
  const res = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${OPENAI_API_KEY}`
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }]
    })
  });
  if (!res.ok) {
    throw new Error(`OpenAI API error: ${res.status} ${await res.text()}`);
  }
  const json = await res.json();
  return json.choices?.[0]?.message?.content?.trim();
}

function applyPatch(patch) {
  execSync('git apply -p0', { input: patch, stdio: ['pipe', 'inherit', 'inherit'] });
}

function repoInfo() {
  const url = execSync('git config --get remote.origin.url').toString().trim();
  const m = url.match(/[:/]([^/]+)\/([^/]+?)(?:\.git)?$/);
  if (!m) throw new Error('Cannot parse origin url');
  return { owner: m[1], repo: m[2] };
}

async function createPR(owner, repo, branch, base, title, body) {
  const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/pulls`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${GITHUB_TOKEN}`
    },
    body: JSON.stringify({ title, head: branch, base, body })
  });
  if (!res.ok) {
    throw new Error(`GitHub API error: ${res.status} ${await res.text()}`);
  }
  const json = await res.json();
  console.log(`Opened PR: ${json.html_url}`);
}

async function main() {
  const junit = parseJUnit(JUNIT_PATH || 'junit.xml');
  const coverage = parseCoverage(COVERAGE_PATH || 'coverage/coverage-summary.json');

  const failureText = junit.length
    ? junit.map(f => `- ${f.classname} ${f.name}: ${f.message}`).join('\n')
    : 'No failing tests found.';
  const coverageText = coverage ? `Coverage:\n${coverage}` : 'No coverage info.';
  const prompt = `Repository state:\n${failureText}\n${coverageText}\nProvide a patch in unified diff format to fix the failing tests.`;

  const patch = await generatePatch(prompt);
  if (!patch) {
    console.error('No patch returned from OpenAI');
    return;
  }

  try {
    applyPatch(patch);
  } catch {
    fs.writeFileSync('codex-fix.patch', patch);
    console.error('Failed to apply patch. Patch written to codex-fix.patch');
    process.exit(1);
  }

  const sha = execSync('git rev-parse --short HEAD').toString().trim();
  const date = new Date().toISOString().slice(0, 10);
  const branch = `fix/codex-${date}-${sha}`;
  execSync(`git checkout -b ${branch}`);
  execSync('git add -A');
  execSync('git commit -m "chore: apply codex fix"');

  const { owner, repo } = repoInfo();
  const base = (() => {
    try {
      return execSync('git symbolic-ref refs/remotes/origin/HEAD').toString().trim().split('/').pop();
    } catch {
      return 'main';
    }
  })();

  try {
    execSync(`git push https://x-access-token:${GITHUB_TOKEN}@github.com/${owner}/${repo}.git ${branch}`, { stdio: 'ignore' });
  } catch {
    fs.writeFileSync('codex-fix.patch', patch);
    console.error('Failed to push changes. Patch written to codex-fix.patch');
    process.exit(1);
  }

  await createPR(owner, repo, branch, base, `Codex fix ${date}`, 'Automated fix generated by Codex.');
}

main().catch(err => {
  console.error(err);
});
